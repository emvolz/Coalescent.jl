var documenterSearchIndex = {"docs":
[{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Coalescent.jl is a package for simulation of coalescent genealogical histories with a flexible markup language for conditioning on demographic history. This package can be used as a building-block in pipelines for simulation-based inference in population genetics research.  ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The focus of this package is on support for simulation under demographic histories featuring nonlinear dynamics, potentially complex state spaces, and complex sampling over time. This makes the package especially relevent for studies of pathogen evolution, but other applications are possible. A design goal of Coalescent.jl is to enable fast and memory-efficient simulation of very large coalescent trees. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Other software: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"msprime A flexible and highly optimised coalescent simulator in Python, but does not currently support complex nonlinear models \nphydynR This is an R package which supports similar specification of demographic processes, but is substantially slower  \nTiPS A recently-developed R package supporting a similar specification of demographic processes \nMASTER A BEAST2 add-on focused on stochastic demographic processes ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Relative to msprime, some major features are currently missing: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Does not currently support recombination (ancestral recombination graphs) \nDetailed models of evolution, which currently must be added on manually ","category":"page"},{"location":"intro/#A-simple-coalescent-simulation","page":"Introduction","title":"A simple coalescent simulation","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"First, let's load the necessary packages:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using Coalescent\nusing Phylo # For plotting trees \nusing Plots # For plotting demographic trajectories\nusing Distributions # For random number generation","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Let's start with a simple coalescent simulation with a constant population size=10 (first argument) and 10 samples:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr = SimTree(10.0, 10)\n@show tr \ntonewick(tr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Simulated coalescent tree with 10 tips and 9 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.1\", \"t.2\", \"t.3\", \"t.4\", \"t.5\", \"t.6\", \"t.7\", \"t\n.8\", \"t.9\", \"t.10\"] ...\n\nRooted; includes branch lengths\ntr = \n\"((((t.4:2.520073107400519,t.5:2.520073107400519):1.3174591901714678,(t.9:1\n.266569944939787,(t.10:0.36999246585678014,(t.1:0.36707169076260365,t.7:0.3\n6707169076260365):0.0029207750941764865):0.8965774790830068):2.570962352632\n2):2.013564887352403,(t.2:1.6115809554183689,t.8:1.6115809554183689):4.2395\n16229506021):5.320626273601084,(t.3:5.617177202174617,t.6:5.617177202174617\n):5.554546256350856):0.0;\"","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tonewick converts the tree to a portable newick string for loading into other software or packages. ","category":"page"},{"location":"intro/#Variable-Population-Size","page":"Introduction","title":"Variable Population Size","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now, let's simulate a coalescent with a variable population size:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr = SimTree((t,p...)->exp(-t), 10)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Simulating coalescent, sample size =10\nInitial guess of time to most recent common ancestor (before most recent sa\nmple): 1.0\nMarkovian coalescent algorithm\nUser-specified Ne(t) function \nSimulated coalescent tree with 10 tips and 9 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.1\", \"t.2\", \"t.3\", \"t.4\", \"t.5\", \"t.6\", \"t.7\", \"t\n.8\", \"t.9\", \"t.10\"] ...\n\nRooted; includes branch lengths","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This creates a tree where the population size increases exponentially over time. Note that in univariate models, the convention is for time to represent time before the most recent sample. Thus time zero always represents when the most recent sample was collected. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We can visualize the tree using Phylo.jl and [Plots.jl]:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tonewick(tr) |> parsenewick |> plot","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/#Parametric-population-size-functions","page":"Introduction","title":"Parametric population size functions","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Suppose we wish to specify the growth rate and initial (most recent) population size in the exponential growth model. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr = SimTree((t,Ne0,λ) -> Ne0*exp(-λ*t), 10, 2_000, 0.25)\n@show tr \ntonewick(tr) |> parsenewick |> plot","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Simulating coalescent, sample size =10\nInitial guess of time to most recent common ancestor (before most recent sa\nmple): 2000.0\nMarkovian coalescent algorithm\nUser-specified Ne(t) function \nSimulated coalescent tree with 10 tips and 9 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.1\", \"t.2\", \"t.3\", \"t.4\", \"t.5\", \"t.6\", \"t.7\", \"t\n.8\", \"t.9\", \"t.10\"] ...\n\nRooted; includes branch lengths\ntr =","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This simulates a population that starts at size Ne0 and declines exponentially with rate λ. Arguments to SimTree folllowing the sample size (10) are passed as arguments to the effective population size function.  So in this case, Ne0=2000 and λ=0.25. ","category":"page"},{"location":"intro/#Logistic-Growth","page":"Introduction","title":"Logistic Growth","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here is a tree simulated under logistic growth and carrying capacity K=100:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"nefunc(t,K) = 10 + K*(1/(1+exp(-(t-5))))\nplot(t->nefunc(t,100), 0, 10)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"These simulations are pretty fast, although for unstructured models, there are faster alternatives. This is how long it takes to simulate a tree with 10 thousand samples and the logistic growth model: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"@time SimTree(nefunc, 10_000, 100)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Simulating coalescent, sample size =10000\nInitial guess of time to most recent common ancestor (before most recent sa\nmple): 10.669285092428485\nMarkovian coalescent algorithm\nUser-specified Ne(t) function \n  0.600311 seconds (12.49 M allocations: 335.358 MiB, 10.20% gc time, 27.40\n% compilation time)\nSimulated coalescent tree with 10000 tips and 9999 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.1\", \"t.2\", \"t.3\", \"t.4\", \"t.5\", \"t.6\", \"t.7\", \"t\n.8\", \"t.9\", \"t.10\"] ...\n\nRooted; includes branch lengths","category":"page"},{"location":"intro/#Population-Bottleneck","page":"Introduction","title":"Population Bottleneck","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We can simulate a population that experiences a sudden bottleneck. In this case, the effective population size drops from 100 to 1 at time 5. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"nefunc(t, Ne1,Ne2,T) = t<T ? Ne1 : Ne2\nplot(t->nefunc(t, 10.0, 1.0, 5.0), 0, 10)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr = SimTree(nefunc, 25, 100.0, 1.0, 5.0)\n@show tr \ntonewick(tr) |> parsenewick |> plot","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Simulating coalescent, sample size =25\nInitial guess of time to most recent common ancestor (before most recent sa\nmple): 100.0\nMarkovian coalescent algorithm\nUser-specified Ne(t) function \nSimulated coalescent tree with 25 tips and 24 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.1\", \"t.2\", \"t.3\", \"t.4\", \"t.5\", \"t.6\", \"t.7\", \"t\n.8\", \"t.9\", \"t.10\"] ...\n\nRooted; includes branch lengths\ntr =","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/#Variable-Sampling-Times","page":"Introduction","title":"Variable Sampling Times","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We can also simulate coalescent trees with samples taken at different times:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr = SimTree(1.0, rand(10))\ntonewick(tr) |> parsenewick |> plot","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Simulating coalescent, sample size =10\nInitial guess of time to most recent common ancestor (before most recent sa\nmple): 1.0\nMarkovian coalescent algorithm\nUser-specified Ne(t) function","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The first argument is Ne, and the second argument is a vector sample times, which in this case were 10 uniform random numbers. ","category":"page"},{"location":"intro/#SIR-Model","page":"Introduction","title":"SIR Model","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The specialty of Coalescent.jl is the simulation of trees under non-linear dynamics.  We'll demonstrate this with the SIR (Susceptible-Infected-Recovered) epidemiological model which is specified by a system of ordinary differential equations. In this case, and in structured models (demonstrated later), there are some important differences regarding how population dynamics are specified: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Time now represents the conventional forward direction. This is different than how time is handled in most coalescent software packages (i.e. msprime), but is necessary to accomodate nonlinear models that are difficult or impossible to solve in retrospective time. \nRather than defining the dynamics with a julia expression, we will define the model in YAML format, usually kept in a separate file, but here we will write the YAML as multiline strings. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"sir_yaml = \"\"\"\nmodelname: example_sir\nbirths:\n  - source: I # Infections generate new infections at this rate \n    recipient: I \n    rate: β*S*I/N\n\ndeaths:\n  - deme: I # Representing recovery of infected individuals\n    rate: γ*I\n\nparameters:\n  - name: β # transmission rate\n    value: 3.0\n  - name: γ # recovery rate \n    value: 2.0\n\ndynamic_variables:\n  - name: I\n    initial_value: 1.0\n  - name: S\n    initial_value: 1e5\n    ode: -β*S*I/N\n  - name: R\n    initial_value: 0.0\n    ode: γ*I\n\nhelpers: # Other variables that can make it easier to define the ODEs \n  - name: N\n    definition: S+I+R\n\ntime: \n  initial: 1.0\n  final: 20.0 \n\"\"\";","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Note that this model schema follows the conventions of so-called FGY models. Specifically: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The genealogical process is defined by several state & time dependant rates that can influence the history of a lineage: Births, Migrations (examples in later sections) and Deaths\nSome dynamical variables correspond to a population size influencing the coalescent rate (\"I\" in this case representing the number of infections), but others represent the state of the system which must be known to determine birth, migration and death rates (\"S\" and \"R\"). We do not decompose dynamics of these variables into birth and death rates, but we must specify an ODE giving the time derivative of these variables. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now we integrate the model and plot a trajectory: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"sirmodel = ModelFGY(confstr = sir_yaml)\n@show sirmodel \nsoln_sirmodel = solveodes(sirmodel)\nplot(soln_sirmodel)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Compartmental model with 1 demes, \nand 2 other dynamic variables.\n\nDynamic variables: [\"I\"], [\"S\", \"R\"]\n\nParameters: \n2×2 DataFrame\n Row │ parameter  value\n     │ String     Float64\n─────┼────────────────────\n   1 │ γ              2.0\n   2 │ β              3.0\n\nInitial conditions: Dict{String, Number}(\"I\" => 1.0, \"S\" => 100000.0, \"R\" =\n> 0.0)\n3×2 DataFrame\n Row │ variable  initial value\n     │ String    Float64\n─────┼─────────────────────────\n   1 │ I                   1.0\n   2 │ S              100000.0\n   3 │ R                   0.0\n\nInitial time: 1.0\n\nFinal time: 20.0\n\nsirmodel =","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now let's define a sampling scheme. There are several ways to do this.  Samples can be defined a particular time and a particular deme (see structured models).  Or julia code can be provided that generates a vector of sample times. Or, a table can be loaded from a file which contains the time and deme of each sample. These can co-exist within the same configuration. Here is an example: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"sirsample_yaml = \"\"\"\nsample: \n  # Take a single sample from deme I at time 10\n  - deme: I\n    time: 15.0 \n    size: 10\n  # Executable Julia code to define sample times. Takes 5 samples from deme I at equal intervals between times 5 and 10. \n  - deme: I\n    time: range( 5.0, 10.0, 5 )\n  # Another example of parsing and executing Julia code; sampling 5 times from a Normal distribution\n  - deme: I\n    time: rand( Normal(10), 5 )\n  # [NOT RUN] Read sample time information from a table\n  #- table: ./sampletimes.csv # A table with columns <sample_time>, <deme>\n\"\"\"\n\nsirsamp = SampleConfiguration(confstr = sirsample_yaml);","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now simulate the tree with the model and sample configuration: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr = SimTree(sirmodel, sirsamp)\ntonewick(tr) |> parsenewick |> plot","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/#Models-with-population-structure","page":"Introduction","title":"Models with population structure","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It is straightforward to specify a model with population structure, nonlinear dynamics, and heterogeneous sampling over time using the FGY yaml format. ","category":"page"},{"location":"intro/#Island-Model","page":"Introduction","title":"Island Model","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"First, let's reproduce the classic island model with 2 demes, a constant migration rate (μ) between demes, and a constant population size in each deme.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The population size is constant because we specify birth rates and death rates to be the same at a per-capita rate γ.  This rate also sets the timescale of the process (one generation = 1/γ).  ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"islandmodel_yaml = \"\"\"\nmodelname: exampleisland\nbirths:\n  - source: A\n    recipient: A\n    rate: γ * A\n  - source: B\n    recipient: B\n    rate: γ * B\nmigrations:\n  - source: A \n    recipient: B \n    rate: μ * A \n  - source: B \n    recipient: A \n    rate: μ * B \ndeaths:\n  - deme: A\n    rate: γ * A\n  - deme: B\n    rate: γ * B\ndynamic_variables:\n  - name: A\n    initial_value: 100.0\n  - name: B\n    initial_value: 100.0\ntime:\n  initial: 0\n  final: 300\nparameters:\n  - name: γ\n    value: 1.0\n  - name: μ\n    value: 0.05\n\"\"\"\n\n# Homochronous sampling from both demes: \nislandsample_yaml = \"\"\" \nsample:\n  - deme: A \n    time: 300\n    size: 20 \n  - deme: B \n    time: 300\n    size: 20 \n\"\"\"\n\nislandmodel = ModelFGY(confstr=islandmodel_yaml)\n@show islandmodel \n\n# Simulate the tree \ntr = SimTree(\n    islandmodel,\n    SampleConfiguration(confstr=islandsample_yaml)\n)\n@show tr \n# Plot the tree: \ntonewick(tr) |> parsenewick |> plot","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Compartmental model with 2 demes, \nand 0 other dynamic variables.\n\nDynamic variables: [\"A\", \"B\"], String[]\n\nParameters: \n2×2 DataFrame\n Row │ parameter  value\n     │ String     Float64\n─────┼────────────────────\n   1 │ γ             1.0\n   2 │ μ             0.05\n\nInitial conditions: Dict{String, Number}(\"B\" => 100.0, \"A\" => 100.0)\n2×2 DataFrame\n Row │ variable  initial value\n     │ String    Float64\n─────┼─────────────────────────\n   1 │ B                 100.0\n   2 │ A                 100.0\n\nInitial time: 0.0\n\nFinal time: 300.0\n\nislandmodel = \nSimulated coalescent tree with 40 tips and 39 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.A.1\", \"t.A.2\", \"t.A.3\", \"t.A.4\", \"t.A.5\", \"t.A.6\n\", \"t.A.7\", \"t.A.8\", \"t.A.9\", \"t.A.10\"] ...\n\nRooted; includes branch lengths\ntr =","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Note that the deme of sampling is embedded in the tip label, which makes it easy to extract in other software. The deme can also be accessed programmatically in tr.demes.","category":"page"},{"location":"intro/#Imbalanced-Migration","page":"Introduction","title":"Imbalanced Migration","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The way migration is handled in FGY models is quite different than most coalescent frameworks. The given rate is always a \"per-capita\" rate in a forwards time direction.  In contrast, most coalescent frameworks specify a migration rate \"per-lineage\" in a reverse time direction. To show the difference, consider this variation on the island model which is the same as above except that deme B starts at size 1 and deme A at size 500.  ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"twodememigration_yaml = \"\"\"\nmodelname: examplemigration\nbirths:\n  - source: A\n    recipient: A\n    rate: γ * A\n  - source: B\n    recipient: B\n    rate: γ * B\nmigrations:\n  - source: A \n    recipient: B \n    rate: μ * A\n  - source: B \n    recipient: A \n    rate: μ * B\ndeaths:\n  - deme: A\n    rate: γ * A\n  - deme: B\n    rate: γ * B\ndynamic_variables:\n  - name: A\n    initial_value: 500.0\n  - name: B\n    initial_value: 1.0\ntime:\n  initial: 0\n  final: 50\nparameters:\n  - name: γ\n    value: 1.0\n  - name: μ\n    value: 0.05\n\"\"\"\n\ntwodememodel = ModelFGY(confstr=twodememigration_yaml)\nsolntwodeme = solveodes(twodememodel) \nplot(solntwodeme)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Because μ is a forward-time per-capita rate, the initial rate of migrations from A to B is 500μ while in the opposite direction it is only 1μ. Thus the populations converge in size over time until the total rate of migrations is the same in both directions. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If you want to use the per-lineage instead per-capita migration rate, it is possible to deduce the \"per-lineage\" retrospective rate of migrations. For example in this model, the per-lineage rate from B to A is μA/B and from A to B it is μB/A. See this paper for details.  ","category":"page"},{"location":"intro/#A-note-about-initial-conditions","page":"Introduction","title":"A note about initial conditions","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A disadvantage of the FGY model format is that the genealogical process is conditioned on a demographic history, and there is no guarantee that the process will coalesce to a single MRCA by the initial time of the simulation. For most applications, it is desired to simulate until this MRCA is reached.  Consider the previous island model and this sampling scheme: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"earlyislandsample_yaml = \"\"\" \nsample:\n  - deme: A \n    time: 1\n    size: 20 \n  - deme: B \n    time: 1\n    size: 20 \n\"\"\";","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this case, all of the samples are collected at time 1 (after the initial time zero), so that there is not time for the process to coalesce. In this case, the simulator will raise a warning and add branches until a MRCA is found based on the distribution of events up to time zero. This is for convenience only, and branches before time zero should not be used for subsequent analysis: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> SimTree(\n           ModelFGY(confstr=islandmodel_yaml),\n           SampleConfiguration(confstr=earlyislandsample_yaml)\n       )\nSimulated coalescent tree with 40 tips and 39 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.A.1\", \"t.A.2\", \"t.A.3\", \"t.A.4\", \"t.A.5\", \"t.A.6\", \"t.A.7\", \"t.A.8\", \"t.A.9\", \"t.A.10\"] ...\n\nRooted; includes branch lengths\n","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"┌ Warning: Coalescent process did not reach a common ancestor. Adding 34 nodes. \n└ @ Coalescent ~/.julia/packages/Coalescent/kfJsL/src/s0.jl:41","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If you get this warning, it will likely be important for your application to revise the model to begin simulation from an earlier time point. ","category":"page"},{"location":"intro/#SEIR-Model","page":"Introduction","title":"SEIR Model","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Finally, let's simulate a coalescent tree based on the SEIR (Susceptible-Exposed-Infected-Recovered) model which will illustrate population structure, nonlinear dynamics, and heterochronous sampling:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"seir_yaml = \"\"\"\nmodelname: example_sir\nbirths:\n  - source: I\n    recipient: E\n    rate: β*S*I/N\nmigrations:\n  - source: E \n    recipient: I \n    rate: γ₁ * E \ndeaths:\n  - deme: I\n    rate: γ₂ * I\nparameters:\n  - name: β \n    value: 6.0\n  - name: γ₁\n    value: 1.0\n  - name: γ₂\n    value: 1.0\ndynamic_variables:\n  - name: E\n    initial_value: 0.1 \n  - name: I\n    initial_value: 0.0\n  - name: S\n    initial_value: 1e3\n    ode: -β*S*I/N\n  - name: R\n    initial_value: 0.0\n    ode: γ*I\nhelpers: \n  - name: N\n    definition: S+E+I+R\ntime: \n  initial: 0.0\n  final: 10.0 \n\"\"\"\n\nseirmodel = ModelFGY(confstr = seir_yaml) \n@show seirmodel\nsoln_seirmodel = solveodes(seirmodel)\nplot(soln_seirmodel)\n\nseirsample_yaml = \"\"\"\nsample:\n  - deme: I\n    time: range(2.0, 10.0, 10)\n\"\"\"\n\nseirsamp = SampleConfiguration(confstr = seirsample_yaml) \ntr = SimTree(seirmodel, seirsamp)\n@show tr \ntonewick(tr) |> parsenewick |> plot","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Compartmental model with 2 demes, \nand 2 other dynamic variables.\n\nDynamic variables: [\"I\", \"E\"], [\"S\", \"R\"]\n\nParameters: \n3×2 DataFrame\n Row │ parameter  value\n     │ String     Float64\n─────┼────────────────────\n   1 │ γ₁             1.0\n   2 │ γ₂             1.0\n   3 │ β              6.0\n\nInitial conditions: Dict{String, Number}(\"I\" => 0.0, \"S\" => 1000.0, \"E\" => \n0.1, \"R\" => 0.0)\n4×2 DataFrame\n Row │ variable  initial value\n     │ String    Float64\n─────┼─────────────────────────\n   1 │ I                   0.0\n   2 │ S                1000.0\n   3 │ E                   0.1\n   4 │ R                   0.0\n\nInitial time: 0.0\n\nFinal time: 10.0\n\nseirmodel = \nSimulated coalescent tree with 10 tips and 9 internal nodes\nTip labels:\n\tUnion{Nothing, String}[\"t.I.1\", \"t.I.2\", \"t.I.4\", \"t.I.8\", \"t.I.11\", \"t.I.\n16\", \"t.I.33\", \"t.I.50\", \"t.I.60\", \"t.I.70\"] ...\n\nRooted; includes branch lengths\ntr =","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this model, lineages are sampled from the \"I\" deme, representing for example microbial genomes collected from symptomatic infected individuals. Migration represents the progression of disease \"E\" to \"I\". Deaths represent recovery of infected individuals. And \"I\" lineages generate new lineages in \"E\" (forwards time) according to a mass action model. ","category":"page"},{"location":"intro/#Computing-Distances","page":"Introduction","title":"Computing Distances","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For some applications related to simulation-based inference, it may be better to work with a distance matrix rather than the tree. We can compute this matrix as follows:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr = SimTree(seirmodel, seirsamp, computedescendants=true)\n# You can modify `tr.edgelength` to simulate various evolutionary models\nCoalescent.distancematrix(tr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"10×10 Matrix{Float64}:\n  0.0      14.9448   12.7552   …  8.09323  8.3108   8.72257  8.30531\n 14.9448    0.0      13.167       9.61146  8.72257  6.75937  7.41642\n 12.7552   13.167     0.0         7.42192  5.02444  6.94479  6.52753\n 11.835    12.2781   10.0886      6.50165  5.64414  6.05591  5.63864\n 10.1032   11.3892    9.19969     4.76983  4.75525  5.16702  4.74975\n  6.81885  10.5003    8.3108   …  3.64878  3.86636  4.27813  3.86086\n  8.09323   9.61146   7.42192     0.0      2.97747  3.38924  2.97197\n  8.3108    8.72257   5.02444     2.97747  0.0      2.50035  2.08309\n  8.72257   6.75937   6.94479     3.38924  2.50035  0.0      1.1942\n  8.30531   7.41642   6.52753     2.97197  2.08309  1.1942   0.0","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Note that the simulator must be called with computedescendants=true in this case which will add modestly to simulation time and substantially to memory usage.  If you wish to simulate an evolutionary model, so that for example distances represent substitutions per site, you can modify the branch lengths (tr.edgelength) before computing the distance matrix. For example, this would simulate a Jukes-Cantor model with substitution rate 0.001 and 10,000 nucleotides: ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"tr.edgelength .= [ Poisson(rate) |> rand for rate in tr.edgelength*10_000*0.001  ]","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"18-element Vector{Union{Nothing, Float64}}:\n 58.0\n  8.0\n  7.0\n 33.0\n 11.0\n  7.0\n  1.0\n 30.0\n  6.0\n 47.0\n  0.0\n  3.0\n  3.0\n 59.0\n  5.0\n  5.0\n  2.0\n  2.0","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Future versions may streamline this simulation. ","category":"page"},{"location":"#Coalescent.jl","page":"Reference","title":"Coalescent.jl","text":"","category":"section"},{"location":"#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"","page":"Reference","title":"Reference","text":"Coalescent.Coalescent","category":"page"},{"location":"#Coalescent.Coalescent","page":"Reference","title":"Coalescent.Coalescent","text":"Coalescent\n\nCoalescent simulation and analysis with flexible markup of demographic processes and sampling patterns. \n\nThis module provides tools for:\n\nSimulating coalescent trees\nHandling structured population models\nSolving ordinary differential equations for population dynamics\nManaging sample configuration\n\n\n\n\n\n","category":"module"},{"location":"#Functions","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"SimTree\ntonewick\nModelFGY\nSampleConfiguration\nsolveodes","category":"page"},{"location":"#Coalescent.SimTree","page":"Reference","title":"Coalescent.SimTree","text":"SimTree\n\nRepresents a simulated coalescent tree.\n\nFields\n\nparent::Array{Union{Nothing,Int}}: Parent nodes\nchild::Array{Union{Nothing,Int}}: Child nodes\nn::Int: Number of tips\nnNode::Int: Number of internal nodes\nedgelength::Array{Union{Nothing,Float64}}: Edge lengths\nheights::Array{Union{Nothing,Float64}}: Node heights\ntiplabs::Array{Union{Nothing,String}}: Tip labels\nshs::Array{Union{Nothing,Float64}}: Sample heights\ndescendants::Union{Nothing,BitMatrix}: Descendant matrix\ndaughters::Union{Nothing,Vector{Tuple{Int, Int, Int, Int}}}: Daughter nodes\ndemes::Union{Nothing,Vector{String}}: Demes for each node\n\n\n\n\n\n","category":"type"},{"location":"#Coalescent.tonewick","page":"Reference","title":"Coalescent.tonewick","text":"tonewick(o)\n\nConvert a SimTree to a Newick format string.\n\nArguments\n\no::SimTree: The SimTree to convert\n\nReturns\n\nString: Newick format representation of the tree\n\n\n\n\n\n","category":"function"},{"location":"#Coalescent.ModelFGY","page":"Reference","title":"Coalescent.ModelFGY","text":"ModelFGY\n\nRepresents a structured Forward-in-time Genealogy (FGY) model for coalescent simulations.\n\nFields\n\nmodelname::String: Name of the model\nbirthrxn::Array{Reaction}: Birth reactions in the model\nmigrationrxn::Array{Reaction}: Migration reactions in the model\ndeathrxn::Array{Reaction}: Death reactions in the model\nnondemerxn::Array{Reaction}: Non-deme reactions in the model\ndemes::Array{String}: Names of demes in the model\nnondemes::Union{Nothing,Array{String}}: Names of non-deme variables\nnumberdemes::Int: Number of demes\nnumbernondemes::Int: Number of non-deme variables\ninitial::Dict{String,Number}: Initial conditions for variables\nt0::Float64: Initial time\ntfin::Float64: Final time\nparameters::Union{Nothing,Dict{String,Number}}: Model parameters\nhelperexprs::Union{Nothing,Array{Expr}}: Helper expressions for the model\n\n\n\n\n\n","category":"type"},{"location":"#Coalescent.SampleConfiguration","page":"Reference","title":"Coalescent.SampleConfiguration","text":"SampleConfiguration\n\nRepresents a configuration for sampling in coalescent simulations.\n\nFields\n\nsconf::Array{Tuple{Union{Nothing,String}, Float64}}: Array of tuples containing deme (or nothing) and sampling time\n\n\n\n\n\n","category":"type"},{"location":"#Coalescent.solveodes","page":"Reference","title":"Coalescent.solveodes","text":"solveodes(model::ModelFGY; odemethod = :(Rosenbrock23()), res::Union{Missing,Int64} = missing)\n\nSolve the ordinary differential equations (ODEs) defined by the given model.\n\nArguments\n\nmodel::ModelFGY: The structured FGY model containing the ODEs to solve\n\nKeywords\n\nodemethod = :(Rosenbrock23()): The ODE solver method to use\nres::Union{Missing,Int64} = missing: The number of time points to return in the solution\n\nReturns\n\nODESolution: The solution of the ODEs\n\n\n\n\n\n","category":"function"},{"location":"#Detailed-Function-Documentation","page":"Reference","title":"Detailed Function Documentation","text":"","category":"section"},{"location":"#SimTree","page":"Reference","title":"SimTree","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"SimTree(Ne::Float64, n::Int64)\nSimTree(Ne::Float64, sampletimes::Array{Float64}, p...;  tmrcaguess::Union{Nothing,Float64}=nothing, algorithm=ALGO_MARKOV)\nSimTree(Ne::Function, sampletimes::Array{Float64}, p...; tmrcaguess::Union{Nothing,Float64}=nothing, algorithm=ALGO_STATIONARY)\nSimTree(Ne::Function, n::Int64, p...; tmrcaguess::Union{Nothing,Float64}=nothing, algorithm=ALGO_MARKOV)\nSimTree(model::ModelFGY, sample::SampleConfiguration; computedescendants = false)","category":"page"},{"location":"#Coalescent.SimTree-Tuple{Float64, Int64}","page":"Reference","title":"Coalescent.SimTree","text":"SimTree(Ne::Float64, n::Int64)::SimTree\n\nSimulate a coalescent tree with constant Ne and n samples at time 0, without specifying tmrcaguess.\n\nArguments\n\nNe::Float64: Constant effective population size\nn::Int64: Number of samples\n\nReturns\n\nSimTree: The simulated coalescent tree\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.SimTree-Tuple{Float64, Array{Float64}, Vararg{Any}}","page":"Reference","title":"Coalescent.SimTree","text":"SimTree(Ne::Float64, sampletimes::Array{Float64}, p...;  tmrcaguess::Union{Nothing,Float64}=nothing, algorithm=ALGO_MARKOV)::SimTree\n\nSimulate a coalescent tree with constant Ne and flexible sampling times.\n\nArguments\n\nNe::Float64: Constant effective population size\nsampletimes::Array{Float64}: Array of sample times\ntmrcaguess::Float64: Initial guess for the time to most recent common ancestor\np...: Additional parameters (unused for constant Ne)\n\nKeywords\n\nalgorithm::String = ALGO_STATIONARY: Algorithm to use for simulation (ALGOSTATIONARY or ALGOMARKOV)\n\nReturns\n\nSimTree: The simulated coalescent tree\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.SimTree-Tuple{Function, Array{Float64}, Vararg{Any}}","page":"Reference","title":"Coalescent.SimTree","text":"SimTree(Ne::Function, sampletimes::Array{Float64}, p...; tmrcaguess::Union{Nothing,Float64}=nothing, algorithm=ALGO_STATIONARY)::SimTree\n\nSimulate a coalescent tree with flexible Ne function and sampling times.\n\nArguments\n\nNe::Function: Effective population size function\nsampletimes::Array{Float64}: Array of sample times\ntmrcaguess::Float64: Initial guess for the time to most recent common ancestor\np...: Additional parameters for the Ne function\n\nKeywords\n\nalgorithm::String = ALGO_MARKOV: Algorithm to use for simulation (ALGOSTATIONARY or ALGOMARKOV)\n\nReturns\n\nSimTree: The simulated coalescent tree\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.SimTree-Tuple{Function, Int64, Vararg{Any}}","page":"Reference","title":"Coalescent.SimTree","text":"SimTree(Ne::Function, n::Int64,p...; tmrcaguess::Union{Nothing,Float64}=nothing, algorithm=ALGO_MARKOV)::SimTree\n\nSimulate a coalescent tree with flexible Ne function and n samples at time 0.\n\nArguments\n\nNe::Function: Effective population size over time function\nn::Int64: Number of samples\ntmrcaguess::Float64: Initial guess for the time to most recent common ancestor\np...: Additional parameters for the Ne function\n\nKeywords\n\nalgorithm::String = ALGO_MARKOV: Algorithm to use for simulation (ALGOSTATIONARY or ALGOMARKOV)\n\nReturns\n\nSimTree: The simulated coalescent tree\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.SimTree-Tuple{ModelFGY, SampleConfiguration}","page":"Reference","title":"Coalescent.SimTree","text":"SimTree(model::ModelFGY, sample::SampleConfiguration; computedescendants = false)\n\nSimulate a coalescent tree based on a given model and sampling configuration.\n\nArguments\n\nmodel::ModelFGY: The structured FGY model to simulate\nsample::SampleConfiguration: The sampling configuration for the simulation\n\nKeywords\n\ncomputedescendants::Bool = false: Whether to compute descendants for each node\n\nReturns\n\nSimTree: A simulated coalescent tree\n\n\n\n\n\n","category":"method"},{"location":"#ModelFGY","page":"Reference","title":"ModelFGY","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"ModelFGY(; modelname::String, birthrxn::Array{Reaction}, migrationrxn::Array{Reaction}, deathrxn::Array{Reaction}, nondemerxn::Array{Reaction}, demes::Array{String}, nondemes::Union{Nothing,Array{String}}, initial::Dict{String,Float64}, t0::Float64, tfin::Float64, parameters::Dict{String,Float64}, helperexprs::Union{Nothing,Array{Expr}})\nModelFGY(conffn::String)","category":"page"},{"location":"#Coalescent.ModelFGY-Tuple{}","page":"Reference","title":"Coalescent.ModelFGY","text":"ModelFGY(; confstr::String)\n\nConstructor for ModelFGY from a YAML configuration string.\n\nArguments\n\nconfstr::String: String defining model in YAML format \n\nReturns\n\nModelFGY: The constructed model\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.ModelFGY-Tuple{String}","page":"Reference","title":"Coalescent.ModelFGY","text":"ModelFGY(conffn::String)\n\nConstructor for ModelFGY from a YAML configuration file.\n\nArguments\n\nconffn::String: Path to the YAML configuration file\n\nReturns\n\nModelFGY: The constructed model\n\n\n\n\n\n","category":"method"},{"location":"#SampleConfiguration","page":"Reference","title":"SampleConfiguration","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"SampleConfiguration(conffn::String)\nSampleConfiguration(; confstr::String)","category":"page"},{"location":"#Coalescent.SampleConfiguration-Tuple{String}","page":"Reference","title":"Coalescent.SampleConfiguration","text":"SampleConfiguration(conffn::String)\n\nCreate a SampleConfiguration from a YAML configuration file.\n\nArguments\n\nconffn::String: Path to the YAML configuration file\n\nReturns\n\nSampleConfiguration: The constructed sampling configuration\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.SampleConfiguration-Tuple{}","page":"Reference","title":"Coalescent.SampleConfiguration","text":"SampleConfiguration(; confstr::String)\n\nCreate a SampleConfiguration from a YAML configuration string.\n\nArguments\n\nconfstr::String: YAML configuration string defining the sampling scheme\n\nReturns\n\nSampleConfiguration: The constructed sampling configuration\n\n\n\n\n\n","category":"method"},{"location":"#Other-Functions","page":"Reference","title":"Other Functions","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"tonewick(o)\nCoalescent.distancematrix(t)\nsolveodes(model::ModelFGY; odemethod = :(Rosenbrock23()), res::Union{Missing,Int64} = missing)","category":"page"},{"location":"#Coalescent.tonewick-Tuple{Any}","page":"Reference","title":"Coalescent.tonewick","text":"tonewick(o)\n\nConvert a SimTree to a Newick format string.\n\nArguments\n\no::SimTree: The SimTree to convert\n\nReturns\n\nString: Newick format representation of the tree\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.distancematrix-Tuple{Any}","page":"Reference","title":"Coalescent.distancematrix","text":"distancematrix(t)::Matrix{Float64}\n\nCompute the distance matrix for a SimTree.\n\nArguments\n\nt::SimTree: The SimTree to compute distances for\n\nReturns\n\nMatrix{Float64}: The computed distance matrix\n\n\n\n\n\n","category":"method"},{"location":"#Coalescent.solveodes-Tuple{ModelFGY}","page":"Reference","title":"Coalescent.solveodes","text":"solveodes(model::ModelFGY; odemethod = :(Rosenbrock23()), res::Union{Missing,Int64} = missing)\n\nSolve the ordinary differential equations (ODEs) defined by the given model.\n\nArguments\n\nmodel::ModelFGY: The structured FGY model containing the ODEs to solve\n\nKeywords\n\nodemethod = :(Rosenbrock23()): The ODE solver method to use\nres::Union{Missing,Int64} = missing: The number of time points to return in the solution\n\nReturns\n\nODESolution: The solution of the ODEs\n\n\n\n\n\n","category":"method"}]
}
